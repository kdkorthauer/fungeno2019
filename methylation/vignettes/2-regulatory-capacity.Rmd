---
title: Exploring the regulatory capacity of DNA methylation 
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
bibliography: ref.bib
---   

```{r, echo=FALSE, message=FALSE, results="hide", cache=FALSE}
library(BiocStyle)
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
set.seed(651)
```

In this vignette, we'll first explore the `BSseq` class of objects for storing bisulfite sequencing data in R. Then we'll go through a reanalysis of a subset of the data from [@ford2017frequent], which concluded that there was not an appreciable reduction in transcription following forced genomewide promoter methylation. The full reanalysis is detailed in [@korthauer2018genome]. The analysis will make use of the `r Biocpkg("dmrseq")` [@korthauer2018detection]. 

# Download data from Ford et al.

In the interest of computational efficiency, for this exercise we'll start with loading a `BSseq` object and only work with chromosome 20. We'll also look only at the control and induced samples (ignoring the withdrawn samples).

> **Note**: this will still take some time to run only on a single chromosome, since the p-value calculation involves permutation. On your laptop, you'll want to go get a hot drink while it runs. On a cluster, you can use multiple cores to obtain a faster runtime.

**How this data was processed**: The original WGBS methylation counts for all cytosines are provided on GEO 
(accession number [GSE102395](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE102395)). The CpG counts were extracted from these files and the data was read into R and bundled as a `BSseq` object. Metadata obtained from the `getGEO()` function and parsed from the filenames was added to the `pData` slot. You can find the code used to carry out these steps in this [Rmd](https://github.com/kdkorthauer/repressivecapacity/blob/master/Rmd/mCG-RNAseq-analysis.Rmd).

```{r}
dblink <- "https://www.dropbox.com/s/heipl6nsy90oekq/bsseq_chr20.rds?dl=1"
dir.create("../data")

bsfile <- "../data/bsseq_chr20.rds"
if (!file.exists(bsfile))
  download.file(dblink, dest=bsfile)
```

Read in chromosome 20 `BSseq` object and check out the metadata in the `pData` slot.

```{r}
library(bsseq)
bs <- readRDS("../data/bsseq_chr20.rds")
bs

colnames(pData(bs))
```

# Anatomy of a `BSseq` object

Here we'll go over basic operations on objects of the class `BSseq`.

```{r}
class(bs)
```

Analogous to `SummarizedExperiment` and `SingleCellExperiment`, `BSseq` is a class for housing bisulfite sequencing data along with its metadata. The main components of the class are:

* **M**: matrix of methylated counts (dimension loci $\by$ samples)
* **Cov**: matrix of coverage counts (dimension loci $\by$ samples)
* **chr**: vector of chromosome names (length loci)
* **pos**: vector of basepair positions (length loci)
* **pData**: data frame of sample metadata (dimension samples $\by$ any number of attributes)
* **sampleNames**: vector of unique sample identifiers (length samples)

These are used to construct a new object. For example:

```{r}
M <- matrix(0:8, 3, 3)
Cov <- matrix(1:9, 3, 3)
chr <- c("chr1", "chr2", "chr1")
pos <- c(1,2,3)
sampleNames = c("A","B", "C")
pData <- data.frame(condition = 1:3,
                    row.names = sampleNames)

testBS <- BSseq(M = M, Cov = Cov,
      chr = chr, pos = pos,
      sampleNames = sampleNames,
      pData=pData)
```

They can all also be accessed via the following getter methods:

* `getCoverage()`: access M and Cov count matrices (use `type="M"` and `type="Cov"`, respectively)
* `seqnames()`: access chromosome information (stored in an `Rle` object; use `as.character` to coerce to character vector)
* `start()`: access basepair position information
* `sampleNames()`: access vector of sample names
* `pData()`: access metadata data frame

```{r}
# get M count
getCoverage(testBS, type="M")

# get Coverage count
getCoverage(testBS, type="Cov")

# get chr
seqnames(testBS)

# get position
start(testBS)

# get sample names
sampleNames(testBS)

# get sample metadata
pData(testBS)
```

Note that you can subset the object by loci (rows) and/or samples (columns), just as you would a `SummarizedExperiment` object, and all the existing slots will be carry through the subsetting accordingly.

```{r}
testBS[2,]
```

***

## Exercise

Extract the methylation counts matrix from the `bs` object. Notice what class it is in.

```{r}
# your code here
```

Using the `pData()` function, tabulate how many samples are in each condition (stored in the `condition` column).

```{r}
# your code here
```

***

## Exploratory analysis

Here will look at some sample similarity metrics among the samples to verify that
control samples are most similar to controls and ZF dox samples are more similar to 
other ZF dox samples (this is indeed the case from the correlation matrix and
clustering dendrogram below).

```{r, fig.height = 3.5, fig.width = 5.75}
library(DelayedMatrixStats)
library(ggplot2)
library(dendextend)
library(dplyr)
library(tidyr)
cov.mat <- getCoverage(bs, type="Cov")
filter <- pmax( 1*(rowSums2(cov.mat[,pData(bs)$condition == "Control"]) >= 5),
                1*(rowSums2(cov.mat[,pData(bs)$condition == "Methylated"]) >= 5))
filter <- which(filter > 0)
bs.filt <- bs[-filter,]
rm(cov.mat)
cormat <- round(cor(as.matrix(getMeth(bs.filt, type="raw")),
                    use = "pairwise.complete.obs", 
                    method = "spearman"),2)
rownames(cormat) <- colnames(cormat) <- labs <- paste0(pData(bs)$condition, 
                                               pData(bs)$dox, 
                                               "_Sample", 1:ncol(cormat))
cormat <- data.frame(cormat) %>%
  mutate(Sample1 = labs) %>%
  gather("Sample2", "Correlation", 1:ncol(cormat))
cormat$Sample1 <- factor(cormat$Sample1) 
cormat$Sample2 <- factor(cormat$Sample2)
ggplot(data = cormat, aes(x=Sample1, y=Sample2, fill=Correlation)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# dendrogram
d <- hclust(dist(t(as.matrix(as.data.frame(getMeth(bs.filt, type="raw")))),
                 method="euclidean"))
d$labels <- pData(bs)$condition
dend <- as.dendrogram(d)
labels_colors(dend) <-as.numeric(pData(bs)$condition)[order.dendrogram(dend)]
plot(dend)
rm(bs.filt)
```

Plots of coverage by group and sample:

```{r, methplot, fig.width = 6, fig.height = 3}
library(dmrseq)
plotEmpiricalDistribution(bs, 
                          bySample = TRUE,
                          testCovariate = "condition",
                          type = "Cov") +
  guides(linetype=FALSE)
```

Plots of beta values by group and sample:

```{r, methplot2, fig.width = 6, fig.height = 3}
plotEmpiricalDistribution(bs, 
                          bySample = TRUE,
                          testCovariate = "condition",
                          adj = 3) +
  guides(linetype=FALSE)
```


# DMR analysis

We will use dmrseq to identify Differentially Methylated Regions (DMRs). 

First we will filter the loci by coverage (remove those with zero coverage
in at least one condition).

```{r, filter}
cov.mat <- getCoverage(bs, type="Cov")
filter <- pmax( 1*(rowSums2(cov.mat[,pData(bs)$condition == "Control"]) == 0),
                1*(rowSums2(cov.mat[,pData(bs)$condition == "Methylated"]) == 0))
filter <- which(filter > 0)
bs <- bs[-filter,]
rm(cov.mat)
```

This removed `r length(filter)` out of `r nrow(bs)` loci (
`r signif(100*length(filter)/nrow(bs), 2)`%). Now we'll run dmrseq.

```{r, dmrseq, message=FALSE}
library(BiocParallel)
register(MulticoreParam(1))
set.seed(399)
resfile <- file.path("../data", "regions.rds")
if (!file.exists(resfile)){
  regions <- dmrseq(bs, testCovariate = "condition",
                    bpSpan = 500,
                    maxGap = 500,
                    maxPerms = 10)
  saveRDS(regions, file=resfile)
}else{
  regions <- readRDS(resfile)
}
sum(regions$qval < 0.1)
```

We'll add the raw mean methylation differences to the region summaries and plot the top 10 DMRs.

```{r, fig.width = 6.5, fig.height= 3}
library(annotatr)
regions$meanDiff <- meanDiff(bs, dmrs=regions, testCovariate="condition")
plotDMRs(bs, regions=regions[1:10,], testCovariate="condition")
```

# DE Analysis

Here we carry out a differential expression analysis using the corresponding RNAseq data from [@ford2017frequent].

First, we download the expression count matrix.

```{r, eval = FALSE}
# expression counts
library(R.utils)
file <- file.path("../data", "GSE102395_MCF7_ZF_DNMT3A_countstable.txt")
if (!file.exists(file)){
  download.file(url = "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE102nnn/GSE102395/suppl/GSE102395%5FMCF7%5FZF%5FDNMT3A%5Fcountstable%2Etxt%2Egz",
              destfile = paste0(file, ".gz"),
              mode="wb")
  gunzip(paste0(file, ".gz"))
}
```
